package pack;
/*	указывает пакет "pack", в котором находится файл класса
	Пакет (package) — это некий контейнер, который используется для того, чтобы изолировать имена классов.
	Например, вы можете создать класс List, заключить его в пакет и не думать после этого о возможных конфликтах, 
	которые могли бы возникнуть если бы кто-нибудь еще создал класс с именем List.
	 */

import javax.swing.*;
/*	Импортируем: 
javax.* — стандартные расширения 
(Стандартные расширения (standard extensions) — это пакеты или наборы пакетов Java)
Swing Библиотека графического интерфейса (конкретный пакет), 
"*"-включение всех элементов библиотеки Swing (jbutton,jpanel,jlabel и т.д.)
(точка) используется для выделения элементов из ссылки на объект.
*/
import java.awt.event.*; /*	java. - Все стандартные классы, поставляемые с системой Java, хранятся в пакете j ava.
	Подключение пакета awt, содержащего базовые графические функции:GridLayout, BorderLayout и т.д.
В отличие от java.awt, javax.swing имеет более гибкую систему управления
	и более широкий набор функций  	
	Подключаем объект event, который содержит свойства, описывающие некое событие.
Каждый раз, когда происходит какое-либо событие, 
объект Event передается соответствующей программе обработки.
Используемым событием в нашей программе являются ACTION события.
*/
import java.awt.*; /*	java. - Все стандартные классы, поставляемые с системой Java, хранятся в пакете j ava.
	подключение пакета awt, содержащего базовые графические функции:GridLayout, BorderLayout и т.д.
В отличие от java.awt, javax.swing имеет более гибкую систему управления
и более широкий набор функций 
*/	

public class Otp extends JPanel {/*	(Public)модификатор доступа, который позволяет программисту управлять видимостью любого метода и любой переменной. 
	В данном случае модификатор доступа public означает, что класс Otp виден и доступен любому классу.
 	В этой строке использовано зарезервированное слово class. 
 	Оно говорит транслятору, что мы собираемся описать новый класс Otp.
  	описываем Otp как класс доступный другим классам (public)
	класс наследует функции элемента JPanel (extends jpanel
	{ <- Полное описание класса располагается между открывающей
	фигурной скобкой в первой строке и парной ей закрывающей фигурной скобкой -> } 
 	*/

    // объявление компонентов на уровне класса
	
	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	private JPanel DanOtp, PokazOtp; /* 	объявляем Панели (JPanel), доступные только внутри класса (private). 
	DanOtp - панель которая содержит надписи и строки: Доход за год, дни отпуска, 
	в которые пользователь должен ввести данные. 
 	PokazOtp - панель которая содержит внутри кнопку 
 	"Рассчитать отпускные" которая описанная ниже
 	*/   
	private JButton PokazOtpBut; /* 	Объявляем кнопку (будет находится на панели PokazOtp)
		Кнопка PokazOtpBut - для показа рассчетов об отпускных. 
	(при нажатии открывается новое окно в котором можно будет увидеть расчет зарплаты)
	Доступно только внутри класса (private)
 	*/
	private JLabel Label_1, Label_2, Label_3; // Объявляем label. Используется для показа текста. Данные поля доступны только внутри класса (private). 
	public static JTextField Text_1year, Text_dni_otp; // текстовые поля в которые пользователь будет вводить данные. Доступно в других классах 

    
    //конструктор
    
	public Otp()  {  /*	Описание метода Otp
		метод видим и доступен для других классов (public)
		круглые скобки говорят о том что мы описываем метод и перед ними идет его название
		Внутри скобок можно указать данные (аргумерты или параметры), которые передаются методу
		*/
		setLayout (new BorderLayout());/*	Оператор new создает экземпляр указанного класса
	  	Метод setLayout - Вызов менеджера компоновки, который задает определенный порядок панелей в контейнере.
 		Менеджер размещения BorderLayout - тип разбивки контейнера, при котором всё пространство контейнера разбивается 
 		на пять частей. В каждой из этих частей располагается один компонент. 
 		При добавлении компонента на контейнер с BorderLayout разработчик обязательно указывает, 
 		куда именно он хочет поместить компонент.
 		*/	
		
		//создаем остальные панели
        DanOtp = new JPanel(); /* панель содержит поля в которые следует ввести данные необходимые для расчета зарплаты
        = new JPanel():  "=" - оператор присваивания переменной DanOtp функций класса JPanel.
          	Оператор new создает экземпляр указанного класса 
          	JPanel() - класс. Является компонентом-контейнером для содержания других частей интерфейса. */
        PokazOtp = new JPanel(); /* панель содержит кнопку Рассчитать (отдельная панель для кнопки нужна для того чтобы кнопка была посередине)
        = new JPanel():  "=" - оператор присваивания переменной DanOtp функций класса JPanel.
      		Оператор new создает экземпляр указанного класса 
      		JPanel() - класс. Является компонентом-контейнером для содержания других частей интерфейса. 
     		*/
        
        //установливаем менеджера расположения для панелей
        DanOtp.setLayout(new FlowLayout(FlowLayout.LEFT, 7, 15));/*setLayout-Вызов менеджера компоновки, который задает определенный порядок панелей в контейнере DanZarp.
      	Менеджер размещения FlowLayout размещает компоненты подобно тому как текстовый редактор располагает слова. 
      	Компоненты располагаются друг за другом слева направо и сверху вниз, начиная с левого верхнего угла. 
      	Если строка заполнена и следующий компонент в ней не помещается, то он переносится на новую строку. 
      	Вокруг каждого компонента оставляется небольшое свободное пространство.
       	Оператор new создает экземпляр указанного класса 
       	7 - горизонтальный отступ, 15 - вертикальный
     	*/
        PokazOtp.setLayout(new GridLayout(1, 1)); /*	setLayout-Вызов менеджера компоновки, который задает определенный порядок панелей в контейнере PokazZarp.
      	Менеджер размещения GridLayout расставляет компоненты в таблицу
      	с заданным в конструкторе числом строк rows и столбцов columns
      	на панели будет 1 строка, 1 столбец,           
       	Это нужно для того чтобы разместить кнопку по центру в плане широты. 
       	Оператор new создает экземпляр указанного класса
     	*/
        
        //добавляем панели на главную панель
        add(DanOtp, BorderLayout.CENTER); /*	add - добавляет указанный компонент DanOtp в контейнер Otp 
      	панель DanOtp, на которой находятся поля ввода текста и поля подписей,
        BorderLayout функция размещения в одной из 5 частей (EAST, WEST, NORTH, SOUTH, CENTER)  
        панель DanOtp находится в центре
    	*/
        add(PokazOtp, BorderLayout.SOUTH); /*	add - добавляет указанный компонент PokazOtp в контейнер Otp 
  		панель DanOtp, на которой находятся поля ввода текста и поля подписей,
    	BorderLayout функция размещения в одной из 5 частей (EAST, WEST, NORTH, SOUTH, CENTER)  
    	панель PokazOtp находится внизу
     	*/
     
        //добавить кнопки и текстовые поля на панели
        addButtonsAndTextFields(); // метод для добавления кнопок и т.д. на панель
		}
	

	//добавление кнопок и текстовых полей на панели
    private void addButtonsAndTextFields() { // описываем метод добавления кнопок и др.компонентов на панели. Метод доступен только в данном классе

        //создаем кнопку
    	PokazOtpBut = new JButton("Рассчитать отпускные"); /*на кнопке надпись Рассчитать отпускные
    	= new JButton():  "=" - оператор присваивания переменной DanOtp функций класса JButton.
          	Оператор new создает экземпляр указанного класса 
          	JButton() - класс. Является компонентом-кнопкой. В скобках указана надпись содержащаяся на кнопке. 
         	*/

        //создать текстовые метки
    	Label_1 = new JLabel("1. Заработок за предыдущий год:", JLabel.LEFT); //текст внутри компонента label находится справа
    	/*	Label_1 - лейбл содержащий надпись "Заработок за предыдущий год:" 
	  	= new JLabel():  "=" - оператор присваивания переменной Dohod1yearLabel функций класса JLabel.
      	Оператор new создает экземпляр указанного класса 
      	JLabel() - класс. Является компонентом-лейблом-областью с обычным текстом. 
      	В скобках указана надпись содержащаяся в этой области. 
	 	*/
    	Label_2 = new JLabel("рублей", JLabel.LEFT);
    	Label_3 = new JLabel("2. Количество дней отпуска:", JLabel.LEFT);

        //создать текстовые поля
    	Text_1year = new JTextField("", 5);
    	/*	Text_1year - текстовое поле в которое мы будем вводить доход за один год
		new JTextField():  "=" - оператор присваивания переменной Text_1year функций класса JTextField.
		Оператор new создает экземпляр указанного класса 
		JTextField() - класс. Является компонентом-текстовым полем. 5 - размер поля
	 	*/
    	Text_1year.setMargin(new Insets(2, 5, 2, 5));//установка внутренних отступов для текстового поля (2-верхний отступ, 5-левый, 2-нижний, 5-правый)
    	Text_1year.setToolTipText("Введите доход за предыдущий год в рублях");//всплывающая подсказка при наведении на текстовое поле
    	Text_dni_otp = new JTextField("", 4);
    	/*	Text_1year - текстовое поле в которое мы будем вводить количество дней отпуска
		new JTextField():  "=" - оператор присваивания переменной Text_dni_otp функций класса JTextField.
		Оператор new создает экземпляр указанного класса 
		JTextField() - класс. Является компонентом-текстовым полем. 4 - размер поля
	 	*/
    	Text_dni_otp.setMargin(new Insets(2, 7, 2, 7));//установка внутренних отступов для текстового поля (2-верхний отступ, 5-левый, 2-нижний, 5-правый)
    	Text_dni_otp.setToolTipText("Введите количество дней отпуска");//всплывающая подсказка при наведении на текстовое поле
  
         	Text_1year.setInputVerifier(new InputVerifier() {
            public boolean verify(JComponent comp) {
                JTextField textField = (JTextField) comp;
                try {
                    Integer.parseInt(textField.getText());
                    return true;
                } catch (NumberFormatException e) {
                    Toolkit.getDefaultToolkit().beep();
                }
                return false;
            }
        });
    	Text_dni_otp.setInputVerifier(new InputVerifier() {
            public boolean verify(JComponent comp) {
                JTextField textField = (JTextField) comp;
                try {
                    Integer.parseInt(textField.getText());
                    return true;
                } catch (NumberFormatException e) {
                    Toolkit.getDefaultToolkit().beep();
                }
                return false;
            }
        });
        
               //добавить кнопки на панели
    	PokazOtp.add(PokazOtpBut); // добавляем кнопку PokazRasBut на панель PokazZarp
    	/* 	PokazOtpBut - кнопка "Рассчитать отпускные"
	  	add - метод добавления компоненты в контейнер.
	  	PokazOtp - панель содержащая только кнопку
	  	*/
    	
        //добавить метки и текстовые поля на панели
    	DanOtp.add(Label_1);
    	DanOtp.add(Text_1year);
    	DanOtp.add(Label_2);
    	DanOtp.add(Label_3);
    	DanOtp.add(Text_dni_otp);
    	/* 	add - метод добавления компоненты в контейнер. */
    	
    	
    	PokazOtpBut.addActionListener(new ActionListener()   
    			/* 	PokazOtpBut - кнопка "Рассчитать отпускные"
        	 	"."  - указывает к какой переменной (кнопке) следует применить слушателя.
        	 	addActionListener - добавление слушателя ActionListener к кнопке
        	  	new - Оператор new создает экземпляр указанного класса 
        	  	(Для того чтобы кнопки стали функциональными, каждой из них необходимо присвоить обработчик событий, 
        	  	который будет отвечать за реагирование на события. 
        	  	В нашем случае требуется идентифицировать событие нажатия кнопки – путем щелчка мышью. 
        	  	Поэтому будет использоваться интерфейс "ActionListener", 
        	  	предназначенный для обработки событий "ActionEvent".
        	  	тело интерфейса указывается ниже после фигурной скобки "{"
        	  	*/
    	   {                                                         
    	    public void actionPerformed(ActionEvent e)      
    	    /* 	ActionListener" имеет метод "actionPerformed" объекта "ActionEvent", 
	      	который реализуется путем простого вызова обработчика событий ActionPerformed.
	      	Ключевое слово public означает, что метод actionPerformed() доступен для любого другого класса Java
	      	Ключевое слово void означает, что метод main() не возвращает данных в программу, которая его вызвала. 
	      	*/
    	    {                                                        
    	    	if ((Interface.isValidInput(Text_1year, "доход за год")) && 
    	    		(Interface.isValidInput(Text_dni_otp, "количество дней отпуска")) )
    	    		/* if - оператор если. * isValidInput проверяет данные на правильность, т.е. 
	    		 	если в текстовые поля Text_1year и Text_dni_otp введены буквы или символы 
	    		 	(текст, который невозможно преобразовать в цифры).
	    		   	Если введены некорректные данные, то выдает ошибку "Введите доход за год" 
	    		  	либо ошибку "Введите количество дней отпуска"
	    		 	*/
    	    	{
    	    	Rasch.RacOtpDanPer();/*	данные которые записаны в текстовые поля преобразовываются в тип Integer и сохраняются в переменные.
    		  	метод RacOtpDanPer записан в классе Rasch
    		  	Слева от точки указывается класс содержащий метод указанный после точки.
    		  	*/
    	    	Interface_Otp.main(null);/* 	что будет происходить при нажатии на кнопку 
				(открывается новая оконная форма класса Interface_Otp - расчет отпускных) 
				программа передает в метод main класса Interface_Otp null. 
				Тем самым происходит запуск метода без передачи переменных 
				*/
    	    	Interface.frame.setVisible(false);//Окно Зарплатный калькулятор становится невидимым
    	    	}
    	    }                                                                   
    	   });  	
    	}
	}


